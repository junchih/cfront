.\" ident	@(#)Array_alg:man/count.3	3.2
.\"
.\" C++ Standard Components, Release 3.0.
.\"
.\" Copyright (c) 1991, 1992 AT&T and UNIX System Laboratories, Inc.
.\" Copyright (c) 1988, 1989, 1990 AT&T.  All Rights Reserved.
.\"
.\" THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T and UNIX System
.\" Laboratories, Inc.  The copyright notice above does not evidence
.\" any actual or intended publication of such source code.
.\" 
.TH \f3count\fP \f3Array_alg(3C++)\fP " "
.SH NAME
count \- count the elements of an array that satisfy a given criterion
.SH SYNOPSIS OF Array_alg.h
.Bf

#include <stddef.h>

    template <class \*(gt>
    ptrdiff_t count(
	const \*(gt& val, 
	const \*(gt* b, 
	const \*(gt* e
    );
    template <class \*(gt>
    ptrdiff_t count_r(
        int (*rel)(const \*(gt*,const \*(gt*),
	const \*(gt& val, 
	const \*(gt* b, 
	const \*(gt* e
    );
    template <class \*(gt>
    ptrdiff_t count_p(
        int (*pred)(const \*(gt*),
	const \*(gt* b, 
	const \*(gt* e
    );
.Be
.SH ASSUMPTIONS
.PP
(1) For the plain version, \*(gt\f4::operator==\f1
defines an equivalence relation on \*(gt
.br
(2) For the relational version, \f4rel\f1 
defines an equivalence relation on \*(gt
.SH DESCRIPTION
.PP
These functions count elements that satisfy some criterion.
.sp 0.5v
.IP "\f4template <class \*(gt>\f1"
.IC "\f4ptrdiff_t count(\f1"
.IC "\f4    const \*(gt& val,\f1" 
.IC "\f4    const \*(gt* b,\f1" 
.IC "\f4    const \*(gt* e\f1"
.IC "\f4);\f1"
Counts elements equal to \f4val\f1, 
as determined by \*(gt\f4::operator==\f1.
.IP "\f4template <class \*(gt>\f1"
.IC "\f4ptrdiff_t count_r(\f1"
.IC "\f4    int (*rel)(const \*(gt*,const \*(gt*),\f1"
.IC "\f4    const \*(gt& val,\f1" 
.IC "\f4    const \*(gt* b,\f1" 
.IC "\f4    const \*(gt* e\f1"
.IC "\f4);\f1"
Like \f4count\f1, but uses \f4rel\f1
to test for equality.  That is, if \f4p\f1 is a
pointer into the array, then \f4*p\f1 
is counted if \f4rel(p,&val)==0\f1.
.IP "\f4template <class \*(gt>\f1"
.IC "\f4ptrdiff_t count_p(\f1"
.IC "\f4    int (*pred)(const \*(gt*),\f1"
.IC "\f4    const \*(gt* b,\f1" 
.IC "\f4    const \*(gt* e\f1"
.IC "\f4);\f1"
Counts elements that satisfy the predicate.  That is,
if \f4p\f1 is a pointer into the array, 
then \f4*p\f1 is counted if \f4pred(p)\f1 is true.
.SH COMPLEXITY
.PP
If \f2N\f1 is the size of the array, then
complexity is \f2O(N)\f1.
Exactly \f2N\f1 tests of the relation are done.
.SH NOTES
Because a Block (see \f3Block(3C++)\f1)
can always be used wherever an array is called for,
Array Algorithms can also be used with Blocks.
In fact, these two components were actually designed 
to be used together.
.SH SEE ALSO
.Bf
\f3intro(.)\f1
\f3Block(3C++)\f1
.Be
